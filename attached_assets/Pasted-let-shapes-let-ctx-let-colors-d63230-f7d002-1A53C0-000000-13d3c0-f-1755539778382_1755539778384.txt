let shapes = [];
let ctx;
let colors = ['#d63230', '#f7d002', '#1A53C0', '#000000', '#13d3c0', '#f23d21', '#1397d8', '#CD417E', '#f595ad'];

function setup() {
	createCanvas(900, 900);
	rectMode(CENTER);
	ctx = drawingContext;
	let count = 15;
	let cellSize = width / count;
	for (let j = 0; j < count; j++) {
		for (let i = 0; i < count; i++) {
			let x = cellSize * i + cellSize / 2;
			let y = cellSize * j + cellSize / 2;
			shapes.push(new Shape(x, y, cellSize));
		}
	}
}

function draw() {
	background('#ffffff');
	for (let i of shapes) {
		i.run();
	}
}

function easeInOutExpo(x) {
	return x === 0
		? 0
		: x === 1
			? 1
			: x < 0.5 ? Math.pow(2, 20 * x - 10) / 2
				: (2 - Math.pow(2, -20 * x + 10)) / 2;
}

class Shape {
	constructor(x, y, w) {
		this.x = x;
		this.y = y;
		this.w = w;
		this.t1 = 45;
		this.t2 = this.t1 + 5;
		this.t3 = this.t2 + 45;
		this.t4 = this.t3 + 5;
		this.shift1 = 0;
		this.shift2 = this.w;
		this.init();
		this.scaleY1 = 1;
		this.scaleY2 = 1;
		this.direction1 = int(random(4)) * (TAU / 4);
		this.shapeType1 = this.shapeType2;
		this.angle1 = int(random(4)) * (TAU / 4);
		this.color1 = random(colors);
	}

	show() {
		push();
		translate(this.x, this.y);
		stroke(0);
		strokeWeight(0);
		noFill();
		rect(0, 0, this.w, this.w);
		ctx.clip();
		fill(0);

		push();
		translate(this.shift1 * cos(this.direction1), this.shift1 * sin(this.direction1));
		if (this.direction1 == 0 || this.direction1 == PI) {
			scale(1, this.scaleY1);
		} else {
			scale(this.scaleY1, 1);
		}
		fill(this.color1);
		circle(0, 0, this.w * 0.4);
		pop();

		push();
		translate(this.shift2 * cos(this.direction2), this.shift2 * sin(this.direction2));
		if (this.direction2 == 0 || this.direction2 == PI) {
			scale(1, this.scaleY2);
		} else {
			scale(this.scaleY2, 1);
		}
		fill(this.color2);
		circle(0, 0, this.w * 0.4);
		pop();

		pop();
	}

	move() {
		this.t++;
		if (0 < this.t && this.t < this.t2) {
			let n = norm(this.t, 0, this.t2 - 1);
			this.shift1 = lerp(0, this.w * 1.5, easeInOutExpo(n));
			this.scaleY1 = lerp(1, 0.0, sin(easeInOutExpo(n) * PI));
		} else if (this.t1 < this.t && this.t < this.t3) {
			let n = norm(this.t, this.t1, this.t3 - 1);
			this.shift2 = lerp(this.w * 1.5, 0, easeInOutExpo(n));
			this.scaleY2 = lerp(1, 0.0, sin(easeInOutExpo(n) * PI));
		} else if (this.t > this.t3) {
			this.init();
		}
	}

	run() {
		this.show();
		this.move();
	}

	init() {
		this.t = -int(random(2000));
		this.shift1 = 0;
		this.shift2 = this.w * 1.5;
		this.direction1 = this.direction2;
		this.direction2 = int(random(4)) * (TAU / 4);
		this.shapeType1 = this.shapeType2;
		this.shapeType2 = 0;
		this.angle1 = this.angle2;
		this.angle2 = int(random(4));
		this.color1 = this.color2;
		this.color2 = random(colors);
	}
}